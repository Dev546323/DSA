skipping kadane's for the time being, seems to confusing. 

for moore- since the target appears more than size/2 times, the frequency will always be ++ for the target. 
let's say 1 is target number appearing more then size/2 times and 2 appears for the rest of the array
2 can't appear more times than 1 hence, answer will always be 1. 

# check water.cpp for 2 pointer approach. 
 basically checking both sides of the vector at the same time. 

# power.cpp uses binary operations to take out the power effeciently, 

# selfpdt.cpp is to take out the product of array except self 

* is the value at operator. 

## we know name of any array is a const pointer. and it always refers to the a[0]
we can use pointer arithematic to change the pointer reference eg, we can use a+2 to make it so that the the a pointer refers to the    a[2] element now. 


relational operators can be used on pointers 

### binary search algo is a kind of linear algo for SORTED arrays. 
 reduces time complexity from n to logn

        rotated array requires a modified binary search. 
        one side of the array will always be sorted. 


    mountain, another version of binary search 

        unique.cpp unique number amongst sorted duplicates. 

    books.cpp first hard problem. 